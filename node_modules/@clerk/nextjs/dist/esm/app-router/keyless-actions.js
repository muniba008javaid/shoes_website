"use server";
import { cookies, headers } from "next/headers";
import { redirect, RedirectType } from "next/navigation";
import { detectClerkMiddleware } from "../server/headers-utils";
import { getKeylessCookieName } from "../server/keyless";
import { canUseKeyless } from "../utils/feature-flags";
async function syncKeylessConfigAction(args) {
  const { claimUrl, publishableKey, secretKey, returnUrl } = args;
  const cookieStore = await cookies();
  cookieStore.set(getKeylessCookieName(), JSON.stringify({ claimUrl, publishableKey, secretKey }), {
    secure: true,
    httpOnly: true
  });
  const request = new Request("https://placeholder.com", { headers: await headers() });
  if (detectClerkMiddleware(request)) {
    redirect(`/clerk-sync-keyless?returnUrl=${returnUrl}`, RedirectType.replace);
    return;
  }
  return;
}
async function createOrReadKeylessAction() {
  if (!canUseKeyless) {
    return null;
  }
  const result = await import("../server/keyless-node.js").then((m) => m.createOrReadKeyless());
  if (!result) {
    return null;
  }
  const { keylessLogger, createKeylessModeMessage } = await import("../server/keyless-log-cache.js");
  keylessLogger == null ? void 0 : keylessLogger.log({
    cacheKey: result.publishableKey,
    msg: createKeylessModeMessage(result)
  });
  const { claimUrl, publishableKey, secretKey, apiKeysUrl } = result;
  void (await cookies()).set(getKeylessCookieName(), JSON.stringify({ claimUrl, publishableKey, secretKey }), {
    secure: false,
    httpOnly: false
  });
  return {
    claimUrl,
    publishableKey,
    apiKeysUrl
  };
}
async function deleteKeylessAction() {
  if (!canUseKeyless) {
    return;
  }
  await import("../server/keyless-node.js").then((m) => m.removeKeyless());
  return;
}
export {
  createOrReadKeylessAction,
  deleteKeylessAction,
  syncKeylessConfigAction
};
